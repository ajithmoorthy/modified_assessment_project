<?xml version="1.0" encoding="UTF-8"?>
<testng-results skipped="0" failed="1" ignored="0" total="1" passed="0">
  <reporter-output>
  </reporter-output>
  <suite name="Default suite" duration-ms="8333" started-at="2019-09-30T14:32:04Z" finished-at="2019-09-30T14:32:12Z">
    <groups>
    </groups>
    <test name="Default test" duration-ms="8333" started-at="2019-09-30T14:32:04Z" finished-at="2019-09-30T14:32:12Z">
      <class name="org.atmecs.website.testscripts.Insights">
        <test-method status="PASS" signature="startReport()[pri:0, instance:org.atmecs.website.testscripts.Insights@548e7350]" name="startReport" is-config="true" duration-ms="281" started-at="2019-09-30T14:32:04Z" finished-at="2019-09-30T14:32:04Z">
          <reporter-output>
          </reporter-output>
        </test-method> <!-- startReport -->
        <test-method status="PASS" signature="baseSetup()[pri:0, instance:org.atmecs.website.testscripts.Insights@548e7350]" name="baseSetup" is-config="true" duration-ms="7265" started-at="2019-09-30T14:32:04Z" finished-at="2019-09-30T14:32:11Z">
          <reporter-output>
          </reporter-output>
        </test-method> <!-- baseSetup -->
        <test-method status="FAIL" signature="validateBlogs(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)[pri:2, instance:org.atmecs.website.testscripts.Insights@548e7350]" name="validateBlogs" duration-ms="1040" started-at="2019-09-30T14:32:11Z" data-provider="insightsdata" finished-at="2019-09-30T14:32:12Z">
          <exception class="org.testng.internal.reflect.MethodMatcherException">
            <message>
              <![CDATA[
Data provider mismatch
Method: validateBlogs([Parameter{index=0, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=1, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=2, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=3, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=4, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=5, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=6, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=7, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=8, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=9, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=10, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=11, type=java.lang.String, declaredAnnotations=[]}])
Arguments: [(java.lang.String) Debunking Myths about AI,(java.lang.String) How Immersive Reality is transforming Healthcare,(java.lang.String) Securing Apache Kafka using trustStore and SASL,(java.lang.String) Explained! Distributed Load testing – How to calculate number of “Load Generators”?,(java.lang.String) Why do I need Istio for microservices?,(java.lang.String) Blockchain – State of POCs,(java.lang.String) Of all the cutting-edge technologies today, Artificial Intelligence is arguably the most important one, given its wide range of potential and prominence. However, AI too has been a victim of some myths and misconceptions which usually surround anything that is popular. Here’s an infographic to debunk the most common myths about AI.,(java.lang.String) Immersive Reality has been a great addition to the development of technology over the past decade. Not only in the entertainment industry, but AR and VR have been reverberating their presence across many industries. According to a report, Healthcare will be spending around $5bn on AR and VR by 2025. Scientists all around the world have been innovating methods and technologies to transform how healthcare industry functions. To understand this better, have a look at the below infographic.,(java.lang.String) Apache Kafka comes with a lot of security features out of the box (at least since version 0.9). But one feature is missing if you deal with sensitive mission critical data: Encryption of the data itself.
 
Talking about Encryption, Kafka Security mainly has three components:

Encryption of data in-flight using SSL/TLS: This component allows your data to be encrypted. This happens between both producers and customers, and consumers and Kafka.This is the most common pattern we see on web.
Authentication using SSL or SASL: This component is to verify the identity. It allows your producers and consumers to authenticate the Kafka cluster. Also, this component is the best way to enable your clients to endorse an identity, for authorization.
Authorization using ACLs (Access Control Lists): After authentication, your Kafka brokers are able to run them against ACLs. This is to determine whether or not a particular client would be authorized to write/read.




,(java.lang.String) xhcbvkb,(java.lang.String) kjfdhkj,(java.lang.String) dsjfh,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,null]]]>
            </message>
            <full-stacktrace>
              <![CDATA[org.testng.internal.reflect.MethodMatcherException: 
Data provider mismatch
Method: validateBlogs([Parameter{index=0, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=1, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=2, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=3, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=4, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=5, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=6, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=7, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=8, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=9, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=10, type=java.lang.String, declaredAnnotations=[]}, Parameter{index=11, type=java.lang.String, declaredAnnotations=[]}])
Arguments: [(java.lang.String) Debunking Myths about AI,(java.lang.String) How Immersive Reality is transforming Healthcare,(java.lang.String) Securing Apache Kafka using trustStore and SASL,(java.lang.String) Explained! Distributed Load testing – How to calculate number of “Load Generators”?,(java.lang.String) Why do I need Istio for microservices?,(java.lang.String) Blockchain – State of POCs,(java.lang.String) Of all the cutting-edge technologies today, Artificial Intelligence is arguably the most important one, given its wide range of potential and prominence. However, AI too has been a victim of some myths and misconceptions which usually surround anything that is popular. Here’s an infographic to debunk the most common myths about AI.,(java.lang.String) Immersive Reality has been a great addition to the development of technology over the past decade. Not only in the entertainment industry, but AR and VR have been reverberating their presence across many industries. According to a report, Healthcare will be spending around $5bn on AR and VR by 2025. Scientists all around the world have been innovating methods and technologies to transform how healthcare industry functions. To understand this better, have a look at the below infographic.,(java.lang.String) Apache Kafka comes with a lot of security features out of the box (at least since version 0.9). But one feature is missing if you deal with sensitive mission critical data: Encryption of the data itself.
 
Talking about Encryption, Kafka Security mainly has three components:

Encryption of data in-flight using SSL/TLS: This component allows your data to be encrypted. This happens between both producers and customers, and consumers and Kafka.This is the most common pattern we see on web.
Authentication using SSL or SASL: This component is to verify the identity. It allows your producers and consumers to authenticate the Kafka cluster. Also, this component is the best way to enable your clients to endorse an identity, for authorization.
Authorization using ACLs (Access Control Lists): After authentication, your Kafka brokers are able to run them against ACLs. This is to determine whether or not a particular client would be authorized to write/read.




,(java.lang.String) xhcbvkb,(java.lang.String) kjfdhkj,(java.lang.String) dsjfh,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,(java.lang.String) ,null]
at org.testng.internal.reflect.DataProviderMethodMatcher.getConformingArguments(DataProviderMethodMatcher.java:45)
at org.testng.internal.Parameters.injectParameters(Parameters.java:796)
at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:983)
at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)
at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)
at org.testng.TestRunner.privateRun(TestRunner.java:648)
at org.testng.TestRunner.run(TestRunner.java:505)
at org.testng.SuiteRunner.runTest(SuiteRunner.java:455)
at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:450)
at org.testng.SuiteRunner.privateRun(SuiteRunner.java:415)
at org.testng.SuiteRunner.run(SuiteRunner.java:364)
at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)
at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:84)
at org.testng.TestNG.runSuitesSequentially(TestNG.java:1208)
at org.testng.TestNG.runSuitesLocally(TestNG.java:1137)
at org.testng.TestNG.runSuites(TestNG.java:1049)
at org.testng.TestNG.run(TestNG.java:1017)
at org.testng.remote.AbstractRemoteTestNG.run(AbstractRemoteTestNG.java:115)
at org.testng.remote.RemoteTestNG.initAndRun(RemoteTestNG.java:251)
at org.testng.remote.RemoteTestNG.main(RemoteTestNG.java:77)
]]>
            </full-stacktrace>
          </exception> <!-- org.testng.internal.reflect.MethodMatcherException -->
          <reporter-output>
          </reporter-output>
        </test-method> <!-- validateBlogs -->
        <test-method status="PASS" signature="endReport()[pri:0, instance:org.atmecs.website.testscripts.Insights@548e7350]" name="endReport" is-config="true" duration-ms="1578" started-at="2019-09-30T14:32:13Z" finished-at="2019-09-30T14:32:14Z">
          <reporter-output>
          </reporter-output>
        </test-method> <!-- endReport -->
      </class> <!-- org.atmecs.website.testscripts.Insights -->
    </test> <!-- Default test -->
  </suite> <!-- Default suite -->
</testng-results>
